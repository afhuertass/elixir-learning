# Maps

```elixir
Mix.install([
  {:vega_lite, "~> 0.1.11"},
  {:kino_vega_lite, "~> 0.1.8"},
  {:req, "~> 0.5.0"},
  {:sweet_xml, "~> 0.7.5"},
  {:floki, "~> 0.37.0"},
  {:tucan, "~> 0.4.1"}
])
```

## Some module

### Finland data exploration

In this simple example I'm building a small app to retrieve statistics'data from the finnish open data. And then we just do fun things

```elixir
defmodule WFServer do
  def api_req(url, params) do
    Req.get!(url, params: params)
  end
end

defmodule GeoFi do
  # Module to access and plot map data from Finland geoserver
  @url_base "http://geo.stat.fi/geoserver/wfs"
  def check_api_access() do
    # check
    resp = Req.get!(@url_base)
    _status = Map.get(resp, :status, "Unknown")

    case resp do
      %{status: 200} -> IO.puts("API is active")
      _ -> IO.puts("API is not active :(")
    end
  end

  def get_municipalities() do
    params = [
      service: "WFS",
      version: "2.0.0",
      request: "GetCapabilities",
      outputFormat: "json"
    ]

    resp = Req.get!(@url_base, params: params)
    _body = Map.get(resp, :body)
  end

  def do_request(year) do
    params = [
      service: "WFS",
      version: "2.0.0",
      request: "getFeature",
      typeName: "vaestoalue:avi_vaki" <> year,
      outputFormat: "json"
    ]

    resp = Req.get!(@url_base, params: params)
    body = Map.get(resp, :body)
    body
  end

  def get_population(year) do
    body = GeoFi.do_request(year)

    %{"features" => features} = body

    data_man =
      Enum.map(features, fn %{"properties" => %{"miehet" => man_pop, "name" => name}} ->
        %{"gender" => "Male", "pop" => man_pop, "muni" => name}
      end)

    data_women =
      Enum.map(
        features,
        fn %{"properties" => %{"naiset" => naiset, "name" => name}} ->
          %{"gender" => "Female", "pop" => naiset, "muni" => name}
        end
      )

    data_man ++ data_women
  end

  def plot_pop(year_val) do
    data = GeoFi.get_population(year_val)

    b =
      Tucan.bar(
        data,
        "muni",
        "pop",
        color_by: "gender",
        mode: :grouped,
        orient: :horizontal
      )
      |> Tucan.set_size(400, 400)
      |> Tucan.set_title("Population Finland per Municipalities - " <> year_val)
      |> Tucan.Axes.set_xy_titles("Population", "Municipality")

    b
  end

  def geo_plot(year) do
    body = GeoFi.do_request(year)
    body
  end

  def get_grid_population() do
    :ok
  end
end
```

```elixir
#data = GeoFi.get_population("2023")
```

```elixir
alias Tucan
```

```elixir
years = [
  "2019",
  "2020",
  "2021",
  "2022",
  "2023"
]

year_select = Kino.Input.select("Select Year", Enum.map(years, fn x -> {x, x} end))

frame = Kino.Frame.new()

Kino.listen(year_select, fn event ->
  %{value: val} = event
  chart = GeoFi.plot_pop(val)
  Kino.Frame.render(frame, chart)
end)

Kino.Layout.grid([year_select, frame])
```

### Geo plots

Let's try to geo plots using Vega

```elixir
alias VegaLite, as: Vl

# Initialize the specification, optionally with some top-level properties
```

```elixir

Vl.new(width: 400, height: 400)
|> Vl.data_from_values(iteration: 1..100, score: 1..100)
# |> Vl.data_from_values([%{iteration: 1, score: 1}, ...])
# |> Vl.data_from_url("...")

# Pick a visual mark for the graphic
|> Vl.mark(:line)
|> Vl.encode_field(:x, "iteration", type: :quantitative)
|> Vl.encode_field(:y, "score", type: :quantitative)

```

```elixir
data = GeoFi.geo_plot("2020")

%{"features" => feats} = data
length(feats)
# Vl.new(width: 400, height: 400)
# |> Vl.data(data)
data_to_map = %{"features" => feats , "format" => "json" }

#Vl.new(width: 400, height: 400)
#|> Vl.data_from_values(data_to_map, format: %{"property" => "features"})
#|> Vl.mark(:geoshape)
data
```

```elixir
guy = Enum.at(feats, 5)


base_map =
  Vl.new(width: 400, height: 400)
  |> Vl.data(  [%{"values" => guy }] )
  |> Vl.projection(type: :equalEarth)
  |> Vl.mark(:geoshape)
  |> Vl.encode_field(:color, "properties.naiset", type: :quantitative)
|> Vl.to_spec()
```

```elixir
base_map =
  Vl.new(width: 400, height: 400)
  |> Vl.data_from_values(feats ,format: :json , type: :featureCollection)
  |> Vl.projection(type: :equalEarth)
  |> Vl.mark(:geoshape)
  |> Vl.encode_field(:color, "properties.naiset", type: :quantitative)
```

```elixir
vl =
  VegaLite.new()
  |> VegaLite.data( values: [
      %{"x" => 1, "y" => 2},
      %{"x" => 2, "y" => 3},
      %{"x" => 3, "y" => 5},
      %{"x" => 4, "y" => 7}
  ] , format: %{"type" => "json" , "property" => "features" })
|> VegaLite.mark(:point)
|> VegaLite.to_spec()

```
